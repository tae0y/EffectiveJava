# EffectiveJava

## 1장
### 1. 생성자 대신 정적 팩터리 메서드
- 시그니처가 같은 생성자가 여러 개 필요하면, 메서드 이름을 서로 다르게 해주면 된다.
- 싱글톤 객체를 사용할 때 유용하다. 객체가 생성되어 있으면, 새로 생성않고 해당 객체를 반환만 해준다.
- 반환할 객체의 클래스를 유연하게 선택할 수 있다.
- 반환타입의 하위타입 객체를 반환할 수 있다.
- 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
- 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체 클래스가 존재하지 않아도 된다.
- 그러나
  - 상속을 하려면 public이나 protected 생성자가 필요하니, 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
  - 해당 메서드의 역할이 무엇인지 파악하기 어려울 수 있다. 반면 생성자는 누가봐도 '객체를 생성'하는 코드이다.

### 2. 생성자에 매개변수가 많다면 빌더
- 빌더 패턴은 계층적으로 설계된 클래스와 함께 쓰기 좋다.
- 매개변수가 많다면 변수별로 setter를 사용해서 설정해줄 수도 있으나 객체가 완성되기 전까지는 일관성이 유지되지 않는다. 
- 그래서 클래스를 불변으로 만들 수 없고, 스레드 안전성을 얻으려면 추가 작업이 필요하다
- 빌더 패턴은 코드가 장황한 편이므로 매개변수가 4개 이상인 경우에 추천한다.

### 3. private 생성자나 열거 타입으로 싱글턴임을 보증
- 싱글턴 객체를 가짜 구현으로 대체할 수 없기 때문에 테스트하기가 어렵다
- 정적 팩터리 메서드로 싱글톤 객체를 생성하고 반환할 수 있다
  - 생성된 객체는 private final, 생성자도 private으로 관리
  - 메서드 참조나 제네릭 팩터리 메서드로 활용할 수도 있다(`Supplier<Elvis>`)
- 리플렉션, 직렬화 등으로 싱글턴 속성이 깨질 수 있다
  - 접근제한해제/`Enum`: `Singleton.class.getDeclaredConstructors()`나 `constructor.setAccessible(true)`로 접근제한을 해제할 수 있다. Java가 내부적으로 열거형 값이 한번만 인스턴스화되도록 보장하기 때문에 Enum을 사용하면 대응할 수 있다. 대신 지연 초기화가 안된다.
  - 역직렬화/`readResolve`: `file.txt`에 class를 작성하고 해당파일을 역직렬화해서 객체를 생성하는 경우 싱글턴 속성이 유지되지 않는다. class 내부에 readResolve 메서드를 구현하면 회피할 수 있다.
  - `clone`/재정의
  - 자세한 내용: [싱글턴 속성을 깨뜨리지 않도록 대응하는 방법](https://www.geeksforgeeks.org/prevent-singleton-pattern-reflection-serialization-cloning/)

### 4. 인스턴스화를 막으려면 private 생성자를 사용
- 정적 멤버만 담은 유틸리티 클래스를 인스턴스화하지 않도록 생성자를 private으로 관리한다. 다만 상속이 불가능해진다.

### 5. 자원 직접 명시 > 의존 객체 주입 (이른바 '의존성주입')
- 미리 멤버로 정의해두지 않고, 생성 시점에 필요한 객체를 주입받을 수 있다
- 혹은 생성자로 서플라이어를 전달받아(`()->Something`) 동적으로 생성해줘도 된다

### 6.같은 객체를 반복하여 생성하지 않기
- 문자열 match 메서드에서 정규표현식을 문자열로 넘기면 매번 Pattern 객체가 생성되고 GC 대상이 된다. 대신 Pattern 객체를 만들어 캐싱해두고 필요할때마다 사용하는 편이 성능면에서도 가독성면에서도 좋다.

### 7. 다쓴 객체는 참조 해제하기
- 해당 참조를 다 썼을때 null로 바꿔준다
- 다만, 객체 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효범위 밖으로 밀어내는 것이다
- 메모리 누수 시나리오
  - 자기 메모리를 직접 관리하는 클래스: 배열로 구현한 스택에서 pop하면 인덱스만 낮춰주는 경우, 비활성 영역에서 참조하는 객체도 유효한 것으로 인식해서 메모리를 해제할 수 없다. 이와 같이 메모리를 직접 관리하는 경우 null을 지정해주어 gc할 수 있게 해야한다.
  - 캐시: 캐시 엔트리의 유효기간을 정확히 정의하기 어려워서 aging방식을 흔히 사용한다. 혹은 WeakHashMap을 사용하여 캐시 외부에서 키를 참조하는 동안만 살아있는 캐시를 만들 수도 있다.
  - 리스너/콜백: 콜백을 등록만하고 명확히 해지하지 않으면 콜백이 쌓여만 간다. 약한참조로 저장하면 가비지 컬렉터가 즉시 수거해간다. 이를테면 WeakHashMap을 사용하자.

### 8. finalizer와 cleaner 사용을 피하기 (그냥 절대 쓰지말자)
- 자바9부터 finalizer가 deprecated되었다. 그러나 cleaner 역시 예측할 수 없고, 느리고, 불필요하다.
- 자바는 객체 회수를 위해 try-with-resources, try-finally를 사용한다.
- 생성자나 직렬화 과정에서 예외가 발생하면 생성되다만 객체에서 악의적인 하위 클래스의 finalizer가 수행될 수 있다. 그리고 finalizer를 정적필드에 참조 할당하여 가비지 컬렉터가 수집하지 못하게 만들고, 일그러진 객체를 사용해 허용되지 않은 작업도 수행할 수 있다. final이 아닌 클래스를 finalizer 공격으로부터 방어하려면 아무 일도 하지 않는 finalize 메서드를 만들어 final로 선언하자.
- 대안
  - finalizer와 cleaner 대신 AutuCloseable을 구현해 사용하면 된다 (팁: 인스턴스별로 close여부를 확인하는 필드를 선언해두고, 해당 필드가 close인데 참조하면 예외를 던지도록 구현해두면 좋다)

### 9. try-finally 보다는 try-with-resources
- AutoCloseable을 구현한 객체는 `try(statements){}` 구문으로 자원을 회수할 수 있다
- finally에서 close메서드를 호출하는 경우, 중첩된 구문에서 디버깅이 어려워지는 문제가 있다
- close를 명시하지 않은 경우 finalizer가 안전망으로 호출되는데, 동작을 보장하지 않는 문제가 있다

### 10. equals는 일반 규약을 지켜 재정의
- 클래스를 확장해 구현했을때 기존 클래스와 확장한 클래스를 정확히 equals 비교할 수는 없다
- equals 메서드 구현 방법 정리
  - `==` 연산자 사용해 자기자신 참조인지 확인
  - `instanceof`로 입력이 올바른 타입인지 확인
  - 입력을 올바른 타입으로 형변환
  - 입력 객체와 자기 자신의 대응되는 핵심필드들이 모두 일치하는지 확인
- 단위테스트
  - 대칭적인가? `a.equals(b) == b.equals(a)`
  - 추이성이 있는가? `if a.equals(b) and b.equals(c) then a.equals(c) is true`
  - 일관적인가? (두 객체가 같다면 앞으로도 계속 같아야 한다. 비교시점에 따라 달라지면 안됨.)
- equals를 재정의할땐 hashcode도 반드시 재정의
- `AutoValue` 라이브러리를 사용하면 자동으로 만들어준다 👍

### 11. equals를 재정의하려거든 hashCode도 재정의
- equals에서 일부 필드만을 사용해서 비교할 수도 있다, 그러나 논리적으로 같은 객체는 hashcode도 같아야하기에 equals를 재정의하면 hashcode도 재정의해줘야 한다. equals에서 포함하지 않은 필드는 반드시 제외하고 hashing 해야 한다. 그 반대는 상관없다.
- 해시 함수 제작 요령을 참조 (라빈 핑거프린트 알고리즘)
- 또는 구아바의 `com.google.common.hash.Hashing`도 좋다

### 12. toString을 항상 재정의
- 좋은 toString이 좋은 로깅을 만든다
- toString()의 포맷을 정하려면 구체적으로, 앞으로 변하지 않게 만들어야 하며
- toString()의 포맷을 정하지 않으려면, 그 이유를 밝혀둬야 한다
- toString에 포함된 값을 얻어올 수 있는 API를 제공해야 toString을 파싱하는 경우를 방지할 수 있다
- `AutoValue` 라이브러리를 사용하면 자동으로 만들어준다 👍

### 13. clone 재정의는 주의해서 진행
- clone을 구현한 A를 상속해서 B클래스를 만들었다. 여기에 clone을 구현한다면
  - 생성자, 팩토리 메서드를 타지 않고 객체가 생성된다
  - super.clone이 호출되는데 B.clone에서 원하는 것과 다를 수 있다
  - 원본/복제의 필드가 같은 레퍼런스를 참조하면 오류가 발생할 수 있다
  - A.clone이 구현되지 않았다면 CloneNotSupportedException이 발생한다
- 차라리 객체를 집어넣으면 복사한 객체를 반환하도록 생성자/팩토리 메서드를 오버로딩해두는 편이 낫다

### 14. Comparable을 구현할까?
- 구현하면 좋다
- 확장한 클래스에서 comparable을 안전하게 구현하는 방법: 독립된 클래스로 만들고, 상위 클래스 인스턴스 필드를 포함시킨다. 그리고 해당 인스턴스를 반환하는 '뷰' 메서드를 제공한다. 이렇게하면 하위 클래스에서 상위 클래스와 혼동되지 않게 comparable을 구현할 수 있다.
- 정렬된 컬렉션은 동치성을 비교할 때 equals대신 compareTo를 사용한다
- ////
