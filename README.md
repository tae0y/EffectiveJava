# EffectiveJava

## 1장
### 1. 생성자 대신 정적 팩터리 메서드
- 시그니처가 같은 생성자가 여러 개 필요하면, 메서드 이름을 서로 다르게 해주면 된다.
- 싱글톤 객체를 사용할 때 유용하다. 객체가 생성되어 있으면, 새로 생성않고 해당 객체를 반환만 해준다.
- 반환할 객체의 클래스를 유연하게 선택할 수 있다.
- 반환타입의 하위타입 객체를 반환할 수 있다.
- 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
- 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체 클래스가 존재하지 않아도 된다.
- 그러나
  - 상속을 하려면 public이나 protected 생성자가 필요하니, 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
  - 해당 메서드의 역할이 무엇인지 파악하기 어려울 수 있다. 반면 생성자는 누가봐도 '객체를 생성'하는 코드이다.

### 2. 생성자에 매개변수가 많다면 빌더
- 빌더 패턴은 계층적으로 설계된 클래스와 함께 쓰기 좋다.
- 매개변수가 많다면 변수별로 setter를 사용해서 설정해줄 수도 있으나 객체가 완성되기 전까지는 일관성이 유지되지 않는다. 
- 그래서 클래스를 불변으로 만들 수 없고, 스레드 안전성을 얻으려면 추가 작업이 필요하다
- 빌더 패턴은 코드가 장황한 편이므로 매개변수가 4개 이상인 경우에 추천한다.

### 3. private 생성자나 열거 타입으로 싱글턴임을 보증
- 싱글턴 객체를 가짜 구현으로 대체할 수 없기 때문에 테스트하기가 어렵다
- 정적 팩터리 메서드로 싱글톤 객체를 생성하고 반환할 수 있다
  - 생성된 객체는 private final, 생성자도 private으로 관리
  - 메서드 참조나 제네릭 팩터리 메서드로 활용할 수도 있다(`Supplier<Elvis>`)
- 리플렉션, 직렬화 등으로 싱글턴 속성이 깨질 수 있다
  - 접근제한해제/`Enum`: `Singleton.class.getDeclaredConstructors()`나 `constructor.setAccessible(true)`로 접근제한을 해제할 수 있다. Java가 내부적으로 열거형 값이 한번만 인스턴스화되도록 보장하기 때문에 Enum을 사용하면 대응할 수 있다. 대신 지연 초기화가 안된다.
  - 역직렬화/`readResolve`: `file.txt`에 class를 작성하고 해당파일을 역직렬화해서 객체를 생성하는 경우 싱글턴 속성이 유지되지 않는다. class 내부에 readResolve 메서드를 구현하면 회피할 수 있다.
  - `clone`/재정의
  - 자세한 내용: [싱글턴 속성을 깨뜨리지 않도록 대응하는 방법](https://www.geeksforgeeks.org/prevent-singleton-pattern-reflection-serialization-cloning/)

### 4. 인스턴스화를 막으려면 private 생성자를 사용
- 정적 멤버만 담은 유틸리티 클래스를 인스턴스화하지 않도록 생성자를 private으로 관리한다. 다만 상속이 불가능해진다.
