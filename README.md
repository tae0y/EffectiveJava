# EffectiveJava

## 1장
### 1. 생성자 대신 정적 팩터리 메서드
- 시그니처가 같은 생성자가 여러 개 필요하면, 메서드 이름을 서로 다르게 해주면 된다.
- 싱글톤 객체를 사용할 때 유용하다. 객체가 생성되어 있으면, 새로 생성않고 해당 객체를 반환만 해준다.
- 반환할 객체의 클래스를 유연하게 선택할 수 있다.
- 반환타입의 하위타입 객체를 반환할 수 있다.
- 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
- 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체 클래스가 존재하지 않아도 된다.
- 그러나
  - 상속을 하려면 public이나 protected 생성자가 필요하니, 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
  - 해당 메서드의 역할이 무엇인지 파악하기 어려울 수 있다. 반면 생성자는 누가봐도 '객체를 생성'하는 코드이다.

### 2. 생성자에 매개변수가 많다면 빌더
- 빌더 패턴은 계층적으로 설계된 클래스와 함께 쓰기 좋다.
- 매개변수가 많다면 변수별로 setter를 사용해서 설정해줄 수도 있으나 객체가 완성되기 전까지는 일관성이 유지되지 않는다. 
- 그래서 클래스를 불변으로 만들 수 없고, 스레드 안전성을 얻으려면 추가 작업이 필요하다
- 빌더 패턴은 코드가 장황한 편이므로 매개변수가 4개 이상인 경우에 추천한다.

### 3. private 생성자나 열거 타입으로 싱글턴임을 보증
- 싱글턴 객체를 가짜 구현으로 대체할 수 없기 때문에 테스트하기가 어렵다
- 정적 팩터리 메서드로 싱글톤 객체를 생성하고 반환할 수 있다
  - 생성된 객체는 private final, 생성자도 private으로 관리
  - 메서드 참조나 제네릭 팩터리 메서드로 활용할 수도 있다(`Supplier<Elvis>`)
- 리플렉션, 직렬화 등으로 싱글턴 속성이 깨질 수 있다
  - 접근제한해제/`Enum`: `Singleton.class.getDeclaredConstructors()`나 `constructor.setAccessible(true)`로 접근제한을 해제할 수 있다. Java가 내부적으로 열거형 값이 한번만 인스턴스화되도록 보장하기 때문에 Enum을 사용하면 대응할 수 있다. 대신 지연 초기화가 안된다.
  - 역직렬화/`readResolve`: `file.txt`에 class를 작성하고 해당파일을 역직렬화해서 객체를 생성하는 경우 싱글턴 속성이 유지되지 않는다. class 내부에 readResolve 메서드를 구현하면 회피할 수 있다.
  - `clone`/재정의
  - 자세한 내용: [싱글턴 속성을 깨뜨리지 않도록 대응하는 방법](https://www.geeksforgeeks.org/prevent-singleton-pattern-reflection-serialization-cloning/)

### 4. 인스턴스화를 막으려면 private 생성자를 사용
- 정적 멤버만 담은 유틸리티 클래스를 인스턴스화하지 않도록 생성자를 private으로 관리한다. 다만 상속이 불가능해진다.

### 5. 자원 직접 명시 > 의존 객체 주입 (이른바 '의존성주입')
- 미리 멤버로 정의해두지 않고, 생성 시점에 필요한 객체를 주입받을 수 있다
- 혹은 생성자로 서플라이어를 전달받아(`()->Something`) 동적으로 생성해줘도 된다

### 6.같은 객체를 반복하여 생성하지 않기
- 문자열 match 메서드에서 정규표현식을 문자열로 넘기면 매번 Pattern 객체가 생성되고 GC 대상이 된다. 대신 Pattern 객체를 만들어 캐싱해두고 필요할때마다 사용하는 편이 성능면에서도 가독성면에서도 좋다.

### 7. 다쓴 객체는 참조 해제하기
- 해당 참조를 다 썼을때 null로 바꿔준다
- 다만, 객체 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효범위 밖으로 밀어내는 것이다
- 메모리 누수 시나리오
  - 자기 메모리를 직접 관리하는 클래스: 배열로 구현한 스택에서 pop하면 인덱스만 낮춰주는 경우, 비활성 영역에서 참조하는 객체도 유효한 것으로 인식해서 메모리를 해제할 수 없다. 이와 같이 메모리를 직접 관리하는 경우 null을 지정해주어 gc할 수 있게 해야한다.
  - 캐시: 캐시 엔트리의 유효기간을 정확히 정의하기 어려워서 aging방식을 흔히 사용한다. 혹은 WeakHashMap을 사용하여 캐시 외부에서 키를 참조하는 동안만 살아있는 캐시를 만들 수도 있다.
  - 리스너/콜백: 콜백을 등록만하고 명확히 해지하지 않으면 콜백이 쌓여만 간다. 약한참조로 저장하면 가비지 컬렉터가 즉시 수거해간다. 이를테면 WeakHashMap을 사용하자.

### 8. finalizer와 cleaner 사용을 피하기 (그냥 절대 쓰지말자)
- 자바9부터 finalizer가 deprecated되었다. 그러나 cleaner 역시 예측할 수 없고, 느리고, 불필요하다.
- 자바는 객체 회수를 위해 try-with-resources, try-finally를 사용한다.
- 생성자나 직렬화 과정에서 예외가 발생하면 생성되다만 객체에서 악의적인 하위 클래스의 finalizer가 수행될 수 있다. 그리고 finalizer를 정적필드에 참조 할당하여 가비지 컬렉터가 수집하지 못하게 만들고, 일그러진 객체를 사용해 허용되지 않은 작업도 수행할 수 있다. final이 아닌 클래스를 finalizer 공격으로부터 방어하려면 아무 일도 하지 않는 finalize 메서드를 만들어 final로 선언하자.
- 대안
  - finalizer와 cleaner 대신 AutuCloseable을 구현해 사용하면 된다 (팁: 인스턴스별로 close여부를 확인하는 필드를 선언해두고, 해당 필드가 close인데 참조하면 예외를 던지도록 구현해두면 좋다)
